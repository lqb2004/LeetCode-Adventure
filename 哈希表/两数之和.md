# 题目描述：
给定一个整数数组` nums `和一个整数目标值 ` target ` ，请你在该数组中找出和为目标值 `target`  的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
你可以按任意顺序返回答案。

## 我的解法（暴力枚举）： 
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                if(nums[i]+nums[j]==target)
                {ans.push_back(i);
                ans.push_back(j);
                return ans;}
            }
        }
        return ans;
    }
};  
 ```

## 哈希表解法：  
 
  

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;   
// unordered_map一种哈希表数据结构，用于快速存储键-值对 
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
//找的是对应的键  
            if (it != hashtable.end()) {
                return {it->second, i};
//返回一个包含两个整数的向量（vector），这两个整数分别是 “已找到元素的索引” 和 “当前元素的索引”，it->second 表示这个指针指向的键值对中 “值” 的部分。
            }
            hashtable[nums[i]] = i;
//nums[i]作为键，i作为值
        }
        return {};
    }
};  
```

1.对比维度	暴力枚举解法	哈希表解法  
2.时间复杂度	O(n²)	       O(n)  
3.空间复杂度	O(1)	       O(n)  
4.适用场景	小规模数组	    大规模数组  
5.核心优势	无额外空间消耗	效率高，线性时间  
