# 题目描述：  
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

## 我的解法：  
```cpp 
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
       unordered_map<int, vector<int>> mp; 
       if(nums.size()==0) return 0;
       sort(nums.begin(),nums.end());
       int k=1;
       mp[nums[0]].push_back(k);
       for(int i=1;i<nums.size();i++){
        if(nums[i]==nums[i-1]+1){
            k++;
            mp[nums[i]].push_back(k);
        }
        else if(nums[i]==nums[i-1]){
            auto it=mp.find(nums[i]);
            it->second[0]=k;
        }
        else{
            k=1;
            mp[nums[i]].push_back(k);
        }
       }
       int max=0;
       
       for (auto it = mp.begin(); it != mp.end(); ++it){
        if(it->second[0] >= max){
            max=it->second[0];}
       }
       return max;
    }
};
```
### 思路：
1.先排序  
2.哈希表键是原数列的值，值是前一个的值加一  
 例：1 2 3；先存键1的值是1，若下一个数是1+1则存键2的值是2;若不是则存该键的值为1;
3.通过对比所有的值来找出最大值  
我的解法时间复杂度为O（Nlogn）,与题目要求O（n）不符

## 标准题解：
```cpp 
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
//创建一个整数类型的哈希集合 num_set，特点是：元素不重复，且查询、插入、除的时间复杂度都是 O (1)。
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
//判断 num 是否是一个连续序列的 “起点”。
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
//循环查找当前序列的下一个元素。
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```
